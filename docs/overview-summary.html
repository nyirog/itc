<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Interval tree clock</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<h1>Interval tree clock</h1>
<p><b>Version:</b> 0.1.0</p>
<p><b>Authors:</b> Nyiro, Gergo (<a href="mailto:gergo.nyiro@gmail.com"><tt>gergo.nyiro@gmail.com</tt></a>).</p>
<p><b>References</b><ul><li><a href="http://gsd.di.uminho.pt/members/cbm/ps/itc2008.pdf">Interval Tree Clocks: A Logical Clock for Dynamic Systems</a></li></ul></p>

<h3><a name="Summary">Summary</a></h3><p>
Interval tree clock (itc) is a good candidate for a logical clock in a
distributed system where the members join and leave the cluster very
often.</p>

Itc offers the following actions:
<ul>
  <li><b>seed</b>: initialize a clock</li>
  <li><b>event</b>: increment the clock</li>
  <li><b>fork</b>: create clock for the new cluster member</li>
  <li><b>join</b>: synchronize the clocks</li>
  <li><b>leq</b>: compare two clocks</li>
</ul>
<h3><a name="Simple_Scenario">Simple Scenario</a></h3>
Initialize a clock:
<pre>1&gt; ClockA0 = itc:seed().
{1,0}</pre>
Create clock for a new cluster member:
<pre>2&gt; [ClockA1, ClockB1] = itc:fork(ClockA0).
[{{1,0},0},{{0,1},0}]</pre>
The order of the clocks (ClockA0, ClockA1, ClockB1) cannot be determied.
<pre>3&gt; itc:leq(ClockA0, ClockA1).
true
4&gt; itc:leq(ClockA1, ClockA0).
true</pre>
An event has to be executed to increment the clocks.
<pre>5&gt; ClockA2 = itc:event(ClockA1).
{{1,0},{0,1,0}}
6&gt; ClockB2 = itc:event(ClockB1).
{{0,1},{0,0,1}}</pre>
So the clocks can be ordered:
<pre>7&gt; itc:leq(ClockA0, ClockA2).
true
8&gt; itc:leq(ClockA2, ClockA0).
false</pre>
If the cluster nodes are synchronized then the clocks can be joined
<pre>9&gt; ClockC3 = itc:join(ClockA2, ClockB2).
{1,1}
10&gt; itc:leq(ClockA2, ClockC3).
true</pre>
and the new clock can be used in the syncronized nodes.

<hr>
<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
